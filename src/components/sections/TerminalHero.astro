---
interface Props {
  name: string;
  title: string;
  prefix?: string;
}

const { name, title, prefix = '$' } = Astro.props;
---

<div class="terminal-hero">
  <div class="terminal-window">
    <div class="terminal-header">
      <span class="terminal-dot red"></span>
      <span class="terminal-dot yellow"></span>
      <span class="terminal-dot green"></span>
      <span class="terminal-title">~/tommy</span>
    </div>
    <div class="terminal-body">
      <div class="terminal-line">
        <span class="prompt">{prefix}</span>
        <span class="command typing" data-text={`whoami`}></span>
        <span class="cursor"></span>
      </div>
      <div class="terminal-line output hidden" data-delay="1500">
        <span class="output-text name-output">{name}</span>
      </div>
      <div class="terminal-line hidden" data-delay="2000">
        <span class="prompt">{prefix}</span>
        <span class="command typing" data-text={`cat title.txt`}></span>
        <span class="cursor"></span>
      </div>
      <div class="terminal-line output hidden" data-delay="3800">
        <span class="output-text title-output">{title}</span>
      </div>
      <div class="terminal-line hidden" data-delay="4300">
        <span class="prompt">{prefix}</span>
        <span class="cursor blink"></span>
      </div>
    </div>
  </div>
</div>

<script>
  function initTerminalAnimation() {
    const terminalLines = document.querySelectorAll('.terminal-line');
    const typingElements = document.querySelectorAll('.typing');

    // Reset all lines
    terminalLines.forEach((line, index) => {
      if (index > 0) {
        line.classList.add('hidden');
      }
    });

    // Reset typing elements
    typingElements.forEach(el => {
      el.textContent = '';
    });

    // Type text character by character
    function typeText(element: Element, text: string, callback?: () => void) {
      let i = 0;
      const cursor = element.nextElementSibling;

      function type() {
        if (i < text.length) {
          element.textContent += text.charAt(i);
          i++;
          setTimeout(type, 50 + Math.random() * 50);
        } else {
          if (cursor) cursor.classList.add('hidden');
          if (callback) setTimeout(callback, 300);
        }
      }
      type();
    }

    // Start animation sequence
    const firstTyping = typingElements[0];
    if (firstTyping) {
      const text = firstTyping.getAttribute('data-text') || '';
      typeText(firstTyping, text, () => {
        // Show output after first command
        setTimeout(() => {
          const outputLine = terminalLines[1];
          if (outputLine) {
            outputLine.classList.remove('hidden');
            outputLine.classList.add('fade-in');
          }

          // Show second command line
          setTimeout(() => {
            const secondCmdLine = terminalLines[2];
            if (secondCmdLine) {
              secondCmdLine.classList.remove('hidden');
              const secondTyping = typingElements[1];
              if (secondTyping) {
                const text2 = secondTyping.getAttribute('data-text') || '';
                typeText(secondTyping, text2, () => {
                  // Show second output
                  setTimeout(() => {
                    const output2 = terminalLines[3];
                    if (output2) {
                      output2.classList.remove('hidden');
                      output2.classList.add('fade-in');
                    }

                    // Show final prompt
                    setTimeout(() => {
                      const finalLine = terminalLines[4];
                      if (finalLine) {
                        finalLine.classList.remove('hidden');
                      }
                    }, 500);
                  }, 300);
                });
              }
            }
          }, 500);
        }, 300);
      });
    }
  }

  // Run on initial load
  initTerminalAnimation();

  // Re-run after View Transitions
  document.addEventListener('astro:after-swap', initTerminalAnimation);
</script>

<style>
  .terminal-hero {
    display: flex;
    justify-content: center;
    padding: 1rem 0 2rem;
  }

  .terminal-window {
    width: 100%;
    max-width: 500px;
    background: var(--gray-900);
    border-radius: 0.75rem;
    overflow: hidden;
    box-shadow: var(--shadow-lg);
    border: 1px solid var(--gray-800);
  }

  .terminal-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    background: var(--gray-800);
    border-bottom: 1px solid var(--gray-700);
  }

  .terminal-dot {
    width: 0.75rem;
    height: 0.75rem;
    border-radius: 50%;
  }

  .terminal-dot.red {
    background: #ff5f56;
  }

  .terminal-dot.yellow {
    background: #ffbd2e;
  }

  .terminal-dot.green {
    background: #27ca40;
  }

  .terminal-title {
    margin-left: auto;
    font-size: var(--text-sm);
    color: var(--gray-400);
  }

  .terminal-body {
    padding: 1.25rem;
    font-family: var(--font-brand);
    font-size: var(--text-md);
    line-height: 1.8;
  }

  .terminal-line {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    min-height: 1.8em;
  }

  .terminal-line.hidden {
    display: none;
  }

  .terminal-line.output {
    padding-left: 0;
  }

  .prompt {
    color: var(--accent-regular);
    font-weight: 600;
  }

  .command {
    color: var(--gray-100);
  }

  .cursor {
    display: inline-block;
    width: 0.6em;
    height: 1.1em;
    background-color: var(--accent-regular);
    vertical-align: text-bottom;
    animation: none;
  }

  .cursor.blink {
    animation: blink 1s step-end infinite;
  }

  .cursor.hidden {
    display: none;
  }

  .output-text {
    color: var(--gray-300);
  }

  .name-output {
    color: var(--accent-light);
    font-weight: 600;
    font-size: var(--text-lg);
  }

  .title-output {
    color: var(--gray-200);
  }

  .fade-in {
    animation: fadeIn 0.3s ease-in;
  }

  @keyframes blink {
    0%, 50% {
      opacity: 1;
    }
    51%, 100% {
      opacity: 0;
    }
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(-5px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @media (min-width: 50em) {
    .terminal-hero {
      padding: 1.5rem 0 2.5rem;
    }

    .terminal-body {
      padding: 1.5rem;
      font-size: var(--text-lg);
    }

    .name-output {
      font-size: var(--text-xl);
    }
  }
</style>
